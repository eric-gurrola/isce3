#ifndef ISCE_CORE_ORBIT_ICC
#error "NewOrbit.icc is an implementation detail of NewOrbit.h"
#endif

#include <isce/except/Error.h>

namespace isce { namespace core {

inline
OrbitPoint & OrbitPoint::operator=(const StateVector & statevec)
{
    if (!statevec.datetime.isClose(datetime)) {
        std::string errmsg = "input state vector datetime (which is " +
                statevec.datetime.isoformat() + ") did not match datetime "
                "of the orbit point (which is " + datetime.isoformat() + ")";
        throw isce::except::InvalidArgument(ISCE_SRCINFO(), errmsg);
    }

    position = statevec.position;
    velocity = statevec.velocity;

    return *this;
}

inline
OrbitPoint::operator StateVector() const
{
    return {datetime, position, velocity};
}

inline
OrbitPoint::OrbitPoint(const DateTime & datetime, Vec3 & position, Vec3 & velocity)
:
    datetime {datetime},
    position {position},
    velocity {velocity}
{}

inline
bool operator==(const OrbitPoint & lhs, const StateVector & rhs)
{
    return lhs.datetime == rhs.datetime &&
           lhs.position == rhs.position &&
           lhs.velocity == rhs.velocity;
}

inline
bool operator==(const StateVector & rhs, const OrbitPoint & lhs)
{
    return lhs.datetime == rhs.datetime &&
           lhs.position == rhs.position &&
           lhs.velocity == rhs.velocity;
}

inline
bool operator!=(const OrbitPoint & lhs, const StateVector & rhs)
{
    return !(lhs == rhs);
}

inline
bool operator!=(const StateVector & lhs, const OrbitPoint & rhs)
{
    return !(lhs == rhs);
}

inline
const_OrbitPoint::operator StateVector() const
{
    return {datetime, position, velocity};
}

inline
bool operator==(const const_OrbitPoint & lhs, const StateVector & rhs)
{
    return lhs.datetime == rhs.datetime &&
           lhs.position == rhs.position &&
           lhs.velocity == rhs.velocity;
}

inline
bool operator==(const StateVector & rhs, const const_OrbitPoint & lhs)
{
    return lhs.datetime == rhs.datetime &&
           lhs.position == rhs.position &&
           lhs.velocity == rhs.velocity;
}

inline
bool operator!=(const const_OrbitPoint & lhs, const StateVector & rhs)
{
    return !(lhs == rhs);
}

inline
bool operator!=(const StateVector & lhs, const const_OrbitPoint & rhs)
{
    return !(lhs == rhs);
}

inline
bool operator==(const const_OrbitPoint & lhs, const OrbitPoint & rhs)
{
    return lhs.datetime == rhs.datetime &&
           lhs.position == rhs.position &&
           lhs.velocity == rhs.velocity;
}

inline
bool operator==(const OrbitPoint & rhs, const const_OrbitPoint & lhs)
{
    return lhs.datetime == rhs.datetime &&
           lhs.position == rhs.position &&
           lhs.velocity == rhs.velocity;
}

inline
bool operator!=(const const_OrbitPoint & lhs, const OrbitPoint & rhs)
{
    return !(lhs == rhs);
}

inline
bool operator!=(const OrbitPoint & lhs, const const_OrbitPoint & rhs)
{
    return !(lhs == rhs);
}

inline
const_OrbitPoint::const_OrbitPoint(
        const DateTime & datetime,
        const Vec3 & position,
        const Vec3 & velocity)
:
    datetime {datetime},
    position {position},
    velocity {velocity}
{}

inline
NewOrbit NewOrbit::from_statevectors(const std::vector<StateVector> & statevecs)
{
    if (statevecs.size() < 2) {
        throw isce::except::InvalidArgument(ISCE_SRCINFO(),
                "at least 2 state vectors are required");
    }

    DateTime refepoch = statevecs[0].datetime;
    TimeDelta spacing = statevecs[1].datetime - statevecs[0].datetime;
    int size = statevecs.size();

    NewOrbit orbit {refepoch, spacing, size};

    for (int i = 0; i < size; ++i) {
        orbit[i] = statevecs[i];
    }

    return orbit;
}

//inline
//NewOrbit NewOrbit::from_h5(const isce::io::IGroup & group)
//{
//}

inline
NewOrbit::NewOrbit(const DateTime & refepoch, const TimeDelta & spacing, int size)
:
    _refepoch {refepoch},
    _time {0., spacing.getTotalSeconds(), size},
    _position (std::size_t(size)),
    _velocity (std::size_t(size))
{}

inline
OrbitPoint NewOrbit::operator[](int idx)
{
    return {_refepoch + _time[idx], _position[idx], _velocity[idx]};
}

inline
const_OrbitPoint NewOrbit::operator[](int idx) const
{
    return {_refepoch + _time[idx], _position[idx], _velocity[idx]};
}

inline
const DateTime & NewOrbit::refepoch() const
{
    return _refepoch;
}

inline
TimeDelta NewOrbit::spacing() const
{
    return _time.spacing();
}

inline
int NewOrbit::size() const
{
    return _time.size();
}

inline
const Linspace<double> & NewOrbit::time() const
{
    return _time;
}

inline
const std::vector<Vec3> & NewOrbit::position() const
{
    return _position;
}

inline
const std::vector<Vec3> & NewOrbit::velocity() const
{
    return _velocity;
}

inline
void NewOrbit::push_back(const StateVector & statevec)
{
    DateTime expected = _refepoch + spacing() * size();
    if (!statevec.datetime.isClose(expected)) {
        std::string errmsg = "input state vector datetime (which is " +
                statevec.datetime.isoformat() + ") did not match expected "
                "datetime of the next orbit point (which is " +
                expected.isoformat() + ")";
        throw isce::except::InvalidArgument(ISCE_SRCINFO(), errmsg);
    }

    _time.resize(size() + 1);

    _position.push_back(statevec.position);
    _velocity.push_back(statevec.velocity);
}

inline
void NewOrbit::resize(int size)
{
    _time.resize(size);
    _position.resize(std::size_t(size));
    _velocity.resize(std::size_t(size));
}

inline
bool NewOrbit::empty() const
{
    return size() == 0;
}

inline
std::vector<StateVector> NewOrbit::to_statevectors() const
{
    std::vector<StateVector> statevecs;

    for (int i = 0; i < size(); ++i) {
        StateVector sv = operator[](i);
        statevecs.push_back(sv);
    }

    return statevecs;
}

inline
bool operator==(const NewOrbit & lhs, const NewOrbit & rhs)
{
    return lhs.refepoch() == rhs.refepoch() &&
           lhs.time() == rhs.time() &&
           lhs.position() == rhs.position() &&
           lhs.velocity() == rhs.velocity();
}

inline
bool operator!=(const NewOrbit & lhs, const NewOrbit & rhs)
{
    return !(lhs == rhs);
}

}}

