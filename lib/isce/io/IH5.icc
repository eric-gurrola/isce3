
#if !defined(ISCE_IO_IH5_ICC)
#error "IH5.icc is an implementation detail of class ResampSlc"
#endif

inline H5::DataType memType2 (const std::type_info &ti) {

	if (ti == typeid(char))
		return H5::PredType::NATIVE_CHAR;
	else if (ti == typeid(unsigned char))
        return H5::PredType::NATIVE_UCHAR;
	else if (ti == typeid(signed char))
		return H5::PredType::NATIVE_SCHAR;
	else if (ti == typeid(short))
		return H5::PredType::NATIVE_SHORT;
	else if (ti == typeid(unsigned short))
		return H5::PredType::NATIVE_USHORT;
	else if (ti == typeid(int))
		return H5::PredType::NATIVE_INT;
	else if (ti == typeid(unsigned int))
		return H5::PredType::NATIVE_UINT;
	else if (ti == typeid(long))
		return H5::PredType::NATIVE_LONG;
	else if (ti == typeid(unsigned long))
		return H5::PredType::NATIVE_ULONG;
	else if (ti == typeid(long long))
		return H5::PredType::NATIVE_LLONG;
	else if (ti == typeid(unsigned long long))
		return H5::PredType::NATIVE_ULLONG;
	else if (ti == typeid(float))
		return H5::PredType::NATIVE_FLOAT;
	else if (ti == typeid(double))
		return H5::PredType::NATIVE_DOUBLE;
	else if (ti == typeid(long double))
		return H5::PredType::NATIVE_LDOUBLE;
	else if (ti == typeid(std::complex<float>)){
        H5::CompType comp(2 * sizeof(float));
        comp.insertMember("r", 0, H5::PredType::NATIVE_FLOAT);
        comp.insertMember("i", sizeof(float), H5::PredType::NATIVE_FLOAT);
        return comp;
    }
	else if (std::type_index(ti) == std::type_index(typeid(std::complex<float>*))){
        H5::CompType comp(2 * sizeof(float));
        comp.insertMember("r", 0, H5::PredType::NATIVE_FLOAT);
        comp.insertMember("i", sizeof(float), H5::PredType::NATIVE_FLOAT);
        return comp;
    }
	else if (ti == typeid(std::complex<double>)) {
        H5::CompType comp(2 * sizeof(double));
        comp.insertMember("r", 0, H5::PredType::NATIVE_DOUBLE);
        comp.insertMember("i", sizeof(double), H5::PredType::NATIVE_DOUBLE);
        return comp;
    }
	else if (std::type_index(ti) == std::type_index(typeid(std::complex<double>))) {
        H5::CompType comp(2 * sizeof(double));
        comp.insertMember("r", 0, H5::PredType::NATIVE_DOUBLE);
        comp.insertMember("i", sizeof(double), H5::PredType::NATIVE_DOUBLE);
        return comp;
    }
	else if (ti == typeid(std::string)){
        return H5::StrType(0, H5T_VARIABLE);
    }
    else if (ti == typeid(char*)) 
        return H5::StrType(0, H5T_VARIABLE);
    else if (ti == typeid(isce::core::FixedString)) {
        H5::StrType strdatatype(H5::PredType::C_S1, 50);
        return strdatatype;
    }
	else {
	    return H5::PredType::NATIVE_FLOAT;//TODO error instead ?
    }
}

template <class T>
inline H5::DataType memType (std::valarray<T> &v) {
     const std::type_info &ti = typeid(T);
     return memType2(ti);
}

template <class T>
inline H5::DataType memType (std::vector<T> &v) {
     const std::type_info &ti = typeid(T);
     return memType2(ti);
}

template <class T>
inline H5::DataType memType (T &v) {
     const std::type_info &ti = typeid(T);
     return memType2(ti);
}

// TODO: All "read" functions below need some templating to tighten the code


/** @param[in] att  Name of the attribute (optional).
 *  @param[out] v Dataset or attribute scalar value.
 *
 *  If input is not empty, reads the attributes value, otherwise, reads the
 *  dataset scalar value.
 *  For dataset/attributes containing more than one elements, see other
 *  function signature. */
template<typename T>
void isce::io::IDataSet::read(T &v, const std::string &att) {
        

    // Check that the parameter that will receive the data read from the file 
    // is a numeric variable
    //static_assert(std::is_arithmetic<T>::value, "Expected a numeric scalar");

    // Check that the dataset/attribute contains a scalar, i.e., rank=0
    if (getRank(att) != 0)
        return;   // TODO Should add a message or something here
    
    if (att.empty()) {
       H5::DataSet::read(&v, memType(v));
    }
    else if (attrExists(att)) {
       // Open the attribute
       H5::Attribute a = openAttribute(att);

       // Read the attribute from file
       a.read(memType(v), &v);  // Order of parameter is reversed compared to 
                                // dataset read
       // Close the attribute
       a.close();
    }
    else {}   // TODO Should warn or throw here

    return;
}


/** @param[in] startIn Raw pointer to array containing the read start location in each dimension.
 *  @param[in] countIn Raw pointer to array containing the number of elements to read in each dimension.
 *  @param[in] strideIn Raw pointer to array containing the reading stride in each dimension.
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller.
 *  startIn, countIn, strideIn must have a number of elements equals to the 
 *  rank of the dataset. 
 *  If startIn is nullptr, reading start location in each dimension is 0.
 *  If countIn is nullptr, full number of element in each dimension is read.
 *  If strideIn is nullptr, stride defaults to 1 in each dimension.
 *
 * Examples:
 * Dataset contains a 3-bands raster. Dimensions are (100,100,3).
 *
 * To retrieve the full second band: 
 * startIn=[0,0,1], countIn=[100,100,1], strideIn=nullptr or [1,1,1].
 *   
 * To retrieve the first band, but only every other elements in X direction:
 * startIn=[0,0,0], countIn=[50,100,1], strideIn=[2,1,1]. */
//TODO: check what happen if startIns is set but no countIn - countis defaults to full which should be
//larger than wha'ts avail given startIn
template<typename T>
void isce::io::IDataSet::read(T * buffer, const int * startIn, 
                                const int * countIn, 
                                const int * strideIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(startIn, countIn, strideIn);	 


    // Check that the selection is valid (no out of bound)
    // TODO - to be adjusted with preferred error/message handling
    if (!dspace.selectValid()){
       std::cout << "Sub-selection of dataset is invalid" << std::endl;
       dspace.close();
       return;
    }

    // Get total number of elements to read
    hssize_t nbElements = dspace.getSelectNpoints();

    // Format the dataspace of the memory to receive the data read from file
    H5::DataSpace memspace = getReadMemorySpace((hsize_t)nbElements);

    // Read the dataset to memory
    H5::DataSet::read(buffer, memType(buffer) , memspace, dspace);
    
    // Close dataset and memory dataspaces
    dspace.close();
    memspace.close();

}


/** @param[in] sliceIn Vector containing an std::slice for each dimension of the dataset
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce::io::IDataSet::read(T * buffer, 
                              const std::vector<std::slice> * slicesIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(slicesIn);	 

    // Check that the selection is valid (no out of bound)
    // TODO - to be adjusted with preferred error/message handling
    if (!dspace.selectValid()){
       std::cout << "Sub-selection of dataset is invalid" << std::endl;
       dspace.close();
       return;
    }

    // Get total number of elements to read
    hssize_t nbElements = dspace.getSelectNpoints();
    
    // Format the dataspace of the memory to receive the data read from file
    H5::DataSpace memspace = getReadMemorySpace((hsize_t)nbElements);

    // Read the dataset to memory
    H5::DataSet::read(buffer, memType(buffer) , memspace, dspace);
    
    // Close dataset and memory dataspaces
    dspace.close();
    memspace.close();

}

/** @param[in] gsliceIn std::gslice for subsetting
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce::io::IDataSet::read(T * buffer, const std::gslice * gsliceIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(gsliceIn);	 

    // Check that the selection is valid (no out of bound)
    // TODO - to be adjusted with preferred error/message handling
    if (!dspace.selectValid()){
       std::cout << "Sub-selection of dataset is invalid" << std::endl;
       dspace.close();
       return;
    }

    // Get total number of elements to read
    hssize_t nbElements = dspace.getSelectNpoints();
    
    // Format the dataspace of the memory to receive the data read from file
    H5::DataSpace memspace = getReadMemorySpace((hsize_t)nbElements);

    // Read the dataset to memory
    H5::DataSet::read(buffer, memType(buffer) , memspace, dspace);
    
    // Close dataset and memory dataspaces
    dspace.close();
    memspace.close();

}

/** @param[out] buffer std::vector that will receive the full dataset.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::vector<T> &buffer) {
   read(buffer, nullptr, nullptr, nullptr);
} 

/** @param[in] startIn std::vector containing the read start location in each dimension.
 *  @param[in] countIn std::vector containing the number of elements to read in each dimension.
 *  @param[in] strideIn std::vector containing the reading stride in each dimension.
 *  @param[out] buffer std::vector that will received the read data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. 
 *
 *  startIn, countIn, strideIn must have a number of elements equals to the 
 *  rank of the dataset. 
 *  If startIn is nullptr, reading start location in each dimension is 0.
 *  If countIn is nullptr, full number of element in each dimension is read.
 *  If strideIn is nullptr, stride defaults to 1 in each dimension. */ 
template<typename T>
void isce::io::IDataSet::read(std::vector<T> &buffer, const std::vector<int> * startIn, 
                                            const std::vector<int> * countIn, 
                                            const std::vector<int> * strideIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace((startIn)  ? startIn->data() : nullptr,
                                            (countIn)  ? countIn->data() : nullptr,
                                            (strideIn) ? strideIn->data() : nullptr);

    // Check that the selection is valid (no out of bound)
    // TODO - to be adjusted with preferred error/message handling
    if (!dspace.selectValid()){
       std::cout << "Sub-selection of dataset is invalid" << std::endl;
       dspace.close();
       return;
    }

    // Get total number of elements to read
    hssize_t nbElements = dspace.getSelectNpoints();
   

    // Format the dataspace of the memory to receive the data read from file
    H5::DataSpace memspace = getReadMemorySpace((hsize_t)nbElements);

    // Size the output container accordingly to the number of elements to be read
    if(buffer.size() < nbElements)
        buffer.resize(nbElements);

    // Read the dataset to memory
    H5::DataSet::read(buffer.data(), memType(buffer) , memspace, dspace);

    // Close dataset and memory dataspaces
    dspace.close();
    memspace.close();

}

/** @param[in] sliceIn Vector containing an std::slice for each dimension of the dataset
 *  @param[out] buffer std::vector that will receive the read data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::vector<T> &buffer, 
                              const std::vector<std::slice> * slicesIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(slicesIn);

    // Check that the selection is valid (no out of bound)
    // TODO - to be adjusted with preferred error/message handling
    if (!dspace.selectValid()){
       std::cout << "Sub-selection of dataset is invalid" << std::endl;
       dspace.close();
       return;
    }

    // Get total number of elements to read
    hssize_t nbElements = dspace.getSelectNpoints();
    
    // Format the dataspace of the memory to receive the data read from file
    H5::DataSpace memspace = getReadMemorySpace((hsize_t)nbElements);

    // Size the output container accordingly to the number of elements to be read
    if(buffer.size() < nbElements)
        buffer.resize(nbElements);

    // Read the dataset to memory
    H5::DataSet::read(buffer.data(), memType(buffer) , memspace, dspace);
    
    // Close dataset and memory dataspaces
    dspace.close();
    memspace.close();

}

/** @param[in] gsliceIn std::gslice for subsetting
 *  @param[out] buffer std::vector that will receive the read data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::vector<T> &buffer, 
                              const std::gslice * gsliceIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(gsliceIn);

    // Check that the selection is valid (no out of bound)
    // TODO - to be adjusted with preferred error/message handling
    if (!dspace.selectValid()){
       std::cout << "Sub-selection of dataset is invalid" << std::endl;
       dspace.close();
       return;
    }

    // Get total number of elements to read
    hssize_t nbElements = dspace.getSelectNpoints();
    
    // Format the dataspace of the memory to receive the data read from file
    H5::DataSpace memspace = getReadMemorySpace((hsize_t)nbElements);

    // Size the output container accordingly to the number of elements to be read
    if(buffer.size() < nbElements)
        buffer.resize(nbElements);

    // Read the dataset to memory
    H5::DataSet::read(buffer.data(), memType(buffer) , memspace, dspace);
    
    // Close dataset and memory dataspaces
    dspace.close();
    memspace.close();

}

/** @param[out] buffer std::valarray that will receive the full dataset.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::valarray<T> &buffer) {
   read(buffer, nullptr, nullptr, nullptr);
} 


/** @param[in] startIn std::valarray containing the read start location in each dimension.
 *  @param[in] countIn std::valarray containing the number of elements to read in each dimension.
 *  @param[in] strideIn std::valarray containing the reading stride in each dimension.
 *  @param[out] buffer std::valarray that will received the read data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. 
 *
 *  startIn, countIn, strideIn must have a number of elements equals to the 
 *  rank of the dataset. 
 *  If startIn is nullptr, reading start location in each dimension is 0.
 *  If countIn is nullptr, full number of element in each dimension is read.
 *  If strideIn is nullptr, stride defaults to 1 in each dimension. */ 
template<typename T>
void isce::io::IDataSet::read(std::valarray<T> &buffer, const std::valarray<int> *startIn, 
                                              const std::valarray<int> *countIn, 
                                              const std::valarray<int> *strideIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace((startIn)  ? &(*startIn)[0] : nullptr,
                                            (countIn)  ? &(*countIn)[0] : nullptr,
                                            (strideIn) ? &(*strideIn)[0] : nullptr);

    // Check that the selection is valid (no out of bound)
    // TODO - to be adjusted with preferred error/message handling
    if (!dspace.selectValid()){
       std::cout << "Sub-selection of dataset is invalid" << std::endl;
       dspace.close();
       return;
    }

    // Get total number of elements to read
    hssize_t nbElements = dspace.getSelectNpoints();
    
    // Format the dataspace of the memory to receive the data read from file
    H5::DataSpace memspace = getReadMemorySpace((hsize_t)nbElements);

    // Size the output container accordingly to the number of elements to be read
    if(buffer.size() < nbElements)
        buffer.resize(nbElements);

    // Read the dataset to memory
    H5::DataSet::read(&buffer[0], memType(buffer) , memspace, dspace);
    
    // Close dataset and memory dataspaces
    dspace.close();
    memspace.close();

}

/** @param[in] sliceIn sts::valarray containing an std::slice for each dimension of the dataset
 *  @param[out] buffer std::valarray that will receive the read data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::valarray<T> &buffer, 
                              const std::vector<std::slice> *slicesIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(slicesIn);

    // Check that the selection is valid (no out of bound)
    // TODO - to be adjusted with preferred error/message handling
    if (!dspace.selectValid()){
       std::cout << "Sub-selection of dataset is invalid" << std::endl;
       dspace.close();
       return;
    }

    // Get total number of elements to read
    hssize_t nbElements = dspace.getSelectNpoints();
    
    // Format the dataspace of the memory to receive the data read from file
    H5::DataSpace memspace = getReadMemorySpace((hsize_t)nbElements);

    // Size the output container accordingly to the number of elements to be read
    if(buffer.size() < nbElements)
        buffer.resize(nbElements);

    // Read the dataset to memory
    H5::DataSet::read(&buffer[0], memType(buffer) , memspace, dspace);
    
    // Close dataset and memory dataspaces
    dspace.close();
    memspace.close();

}

/** @param[in] gsliceIn std::gslice for subsetting
 *  @param[out] buffer std::valarray that will receive the read data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::valarray<T> &buffer, 
                              const std::gslice *gsliceIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(gsliceIn);

    // Check that the selection is valid (no out of bound)
    // TODO - to be adjusted with preferred error/message handling
    if (!dspace.selectValid()){
       std::cout << "Sub-selection of dataset is invalid" << std::endl;
       dspace.close();
       return;
    }

    // Get total number of elements to read
    hssize_t nbElements = dspace.getSelectNpoints();
    
    // Format the dataspace of the memory to receive the data read from file
    H5::DataSpace memspace = getReadMemorySpace((hsize_t)nbElements);

    // Size the output container accordingly to the number of elements to be read
    if(buffer.size() < nbElements)
        buffer.resize(nbElements);

    // Read the dataset to memory
    H5::DataSet::read(&buffer[0], memType(buffer) , memspace, dspace);
    
    // Close dataset and memory dataspaces
    dspace.close();
    memspace.close();

}

/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce::io::IDataSet::read(T *buffer, const std::string &att) { 

    // Check that attribute name is not null or empty
    // TODO Should add a message or something here
    if (!attrExists(att))
        return;

    // Open the attribute
    H5::Attribute a = openAttribute(att);

    // Read the dataset to memory
    a.read(memType(buffer), buffer);

    // Close the attribute
    a.close();
}






/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer std::vector will received the attribute data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::vector<T> &buffer, const std::string &att) { 

    // Check that attribute name is not null or empty
    // TODO Should add a message or something here
    if (!attrExists(att))
        return;

    // Get number of elements in that attribute       
    int nbElements = getNumElements(att);

    // Open the attribute
    H5::Attribute a = openAttribute(att);

    // Size the output container accordingly to the number of elements read
    if(buffer.size() < nbElements)
        buffer.resize(nbElements);

    // Read the dataset to memory
    a.read(memType(buffer), buffer.data());

    // Close the attribute
    a.close();
}



/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer std::valarray will received the attribute data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::valarray<T> &buffer, const std::string &att) { 

    // Check that attribute name is not null or empty
    // TODO Should add a message or something here
    if (!attrExists(att))
        return;

    // Get number of elements in that attribute       
    int nbElements = getNumElements(att);

    // Open the attribute
    H5::Attribute a = openAttribute(att);

    // Size the output container accordingly to the number of elements read
    if(buffer.size() < nbElements)
        buffer.resize(nbElements);

    // Read the dataset to memory
    a.read(memType(buffer), &buffer[0]);

    // Close the attribute
    a.close();
}

/** @param[in] att  Name of the attribute 
 *  @param[out] v   Attribute scalar value (numeric type).
 *
 *  Reads the value of the numeral attribute contained in the current group.
 *  For attribute containing more than one element, see other function 
 *  signature. For attribute of string type, see other signature.*/
template<typename T>
void isce::io::IGroup::read(T &v, const std::string &att) {
         
    // Check that the parameter that will receive the data read from the file 
    // is a numeric variable
    //static_assert(std::is_arithmetic<T>::value, "Expected a numeric scalar");
    if (attrExists(att)) {
       // Open the attribute
       H5::Attribute a = openAttribute(att);

       // Get the dataSpace of the attribute
       H5::DataSpace dspace = a.getSpace();

       // If attribute contains a scalar or a 1-element array, read the attribute's 
       // value
       if (dspace.getSimpleExtentNdims() == 0)
          a.read(memType(v), &v);
       
       else {} // TODO warning/trow? 
                                   
                                            
       // Close the attribute and dataspace
       a.close();
       dspace.close();
    }
    else {}   // TODO Should warn or throw here

    return;
}

// end of file
