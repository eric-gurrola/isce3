
#if !defined(ISCE_IO_IH5_ICC)
#error "IH5.icc is an implementation detail of class IDataset/IGroup/IH5File"
#endif

template<typename T>
inline H5::DataType getH5Type() {
    if (std::is_same<T, char>())
		return H5::PredType::NATIVE_CHAR;
    else if (std::is_same<T, unsigned char>())
        return H5::PredType::NATIVE_UCHAR;
    else if (std::is_same<T, signed char>())
		return H5::PredType::NATIVE_SCHAR;
    else if (std::is_same<T, short>())
		return H5::PredType::NATIVE_SHORT;
    else if (std::is_same<T, unsigned short>())
		return H5::PredType::NATIVE_USHORT;
    else if (std::is_same<T, int>())
		return H5::PredType::NATIVE_INT;
    else if (std::is_same<T, unsigned int>())
		return H5::PredType::NATIVE_UINT;
    else if (std::is_same<T, long>())
		return H5::PredType::NATIVE_LONG;
    else if (std::is_same<T, unsigned long>())
		return H5::PredType::NATIVE_ULONG;
    else if (std::is_same<T, long long>())
		return H5::PredType::NATIVE_LLONG;
    else if (std::is_same<T, unsigned long long>())
		return H5::PredType::NATIVE_ULLONG;
    else if (std::is_same<T, float>())
		return H5::PredType::NATIVE_FLOAT;
    else if (std::is_same<T, double>())
		return H5::PredType::NATIVE_DOUBLE;
    else if (std::is_same<T, long double>())
		return H5::PredType::NATIVE_LDOUBLE;
    else if (std::is_same<T, isce::io::n1bit>()) {
       H5::IntType datatype(H5::PredType::NATIVE_UINT8);
       datatype.setOffset(0);
       datatype.setPrecision(1);
       return datatype;
    }
    else if (std::is_same<T, isce::io::n2bit>()) {
       H5::IntType datatype(H5::PredType::NATIVE_UINT8);
       datatype.setOffset(0);
       datatype.setPrecision(2);
       return datatype;
    }
    else if (std::is_same<T, isce::io::float16>()){
        H5::FloatType datatype( H5::PredType::NATIVE_FLOAT);
        datatype.setFields(15, 10, 5, 0, 10);
        datatype.setOffset(0);
        datatype.setPrecision(16);
        datatype.setEbias(15);
        datatype.setInpad(H5T_PAD_ZERO);
        return datatype;
    }
    else if (std::is_same<T, std::complex<float>>()){
        H5::CompType comp(2 * sizeof(float));
        comp.insertMember("r", 0, H5::PredType::NATIVE_FLOAT);
        comp.insertMember("i", sizeof(float), H5::PredType::NATIVE_FLOAT);
        return comp;
    }
    else if (std::is_same<T, std::complex<short>>()){
        H5::CompType comp(2 * sizeof(short));
        comp.insertMember("r", 0, H5::PredType::NATIVE_SHORT);
        comp.insertMember("i", sizeof(short), H5::PredType::NATIVE_SHORT);
        return comp;
    }
    else if (std::is_same<T, std::complex<int>>()){
        H5::CompType comp(2 * sizeof(int));
        comp.insertMember("r", 0, H5::PredType::NATIVE_INT);
        comp.insertMember("i", sizeof(int), H5::PredType::NATIVE_INT);
        return comp;
    }
    else if (std::is_same<T, std::complex<isce::io::float16>>()){
        H5::FloatType datatype( H5::PredType::NATIVE_FLOAT);
        datatype.setFields(15, 10, 5, 0, 10);
        datatype.setOffset(0);
        datatype.setPrecision(16);
        datatype.setEbias(15);
        datatype.setInpad(H5T_PAD_ZERO);

        H5::CompType comp(2 * sizeof(float));
        comp.insertMember("r", 0, datatype);
        comp.insertMember("i", sizeof(float), datatype);
        datatype.close();
        return comp;
    }
    else if (std::is_same<T, std::complex<double>>()){
        H5::CompType comp(2 * sizeof(double));
        comp.insertMember("r", 0, H5::PredType::NATIVE_DOUBLE);
        comp.insertMember("i", sizeof(double), H5::PredType::NATIVE_DOUBLE);
        return comp;
    }
    else if (std::is_same<T, std::string>()){
        H5::StrType strdatatype(H5::PredType::C_S1, isce::io::STRLENGTH);
        return strdatatype;
    }
    else if (std::is_same<T, isce::core::FixedString>()){
        H5::StrType strdatatype(H5::PredType::C_S1, isce::io::STRLENGTH);
        return strdatatype;
    }
    else if (std::is_same<T, char*>()){
        H5::StrType strdatatype(H5::PredType::C_S1, isce::io::STRLENGTH);
        return strdatatype;
    }
	else {
        std::cout << "WARNING: (" << typeid(T).name() << ") is an unrecognised type of memory container! Defaulting to float." << std::endl;
	    return H5::PredType::NATIVE_FLOAT;//TODO error instead ?
    }
}




template<typename T>
H5::DataSpace getReadMemorySpace(const T nbElements) {

    // Create a memory dataSpace describing the dataspace of the memory buffer
    // that will receive the data. It's set up as a 1D array.
    hsize_t memDims[1] = {static_cast<hsize_t>(nbElements)};
    H5::DataSpace memspace(1,memDims);
    return memspace;
}


template<typename T, size_t S>
H5::DataSpace getReadMemorySpace(const std::array<T, S>& dims) {

    // Create a memory dataSpace describing the dataspace of the memory buffer
    int rank = dims.size();
    hsize_t *memDims = new hsize_t[rank]();
    for(int i=0; i<rank; i++)
       memDims[i] = static_cast<hsize_t>(dims[i]);
    
    H5::DataSpace memspace(rank, memDims);
    
    return memspace;
}





/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 *                                          IDATASET CLASS
 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
*/


// TODO: All "read" functions below need some templating to tighten the code


/**  @param[in] att  Name of the attribute (optional).
 *  @param[out] v Dataset or attribute scalar value.
 *
 *  If input is not empty, reads the attributes value, otherwise, reads the
 *  dataset scalar value.
 *  For dataset/attributes containing more than one elements, see other
 *  function signature. */
template<typename T>
void isce::io::IDataSet::read(T &v, const std::string &att) {
        

    // Check that the parameter that will receive the data read from the file 
    // is a numeric variable
    //static_assert(std::is_arithmetic<T>::value, "Expected a numeric scalar");

    // Check that the dataset/attribute contains a scalar, i.e., rank=0
    if (getRank(att) != 0)
        return;   // TODO Should add a message or something here
    
    if (att.empty()) {
       //H5::DataSet::read(&v, memType(v));
       H5::DataSet::read(&v, getH5Type<T>());
    }
    else if (attrExists(att)) {
       // Open the attribute
       H5::Attribute a = openAttribute(att);

       // Read the attribute from file
       a.read(getH5Type<T>(), &v);  // Order of parameter is reversed compared to 
                                    // dataset read
       // Close the attribute
       a.close();
    }
    else {}   // TODO Should warn or throw here

    return;
}


/** @param[in] startIn Raw pointer to array containing the read start location in each dimension.
 *  @param[in] countIn Raw pointer to array containing the number of elements to read in each dimension.
 *  @param[in] strideIn Raw pointer to array containing the reading stride in each dimension.
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller.
 *  startIn, countIn, strideIn must have a number of elements equals to the 
 *  rank of the dataset. 
 *  If startIn is nullptr, reading start location in each dimension is 0.
 *  If countIn is nullptr, full number of element in each dimension is read.
 *  If strideIn is nullptr, stride defaults to 1 in each dimension.
 *
 * Examples:
 * Dataset contains a 3-bands raster. Dimensions are (100,100,3).
 *
 * To retrieve the full second band: 
 * startIn=[0,0,1], countIn=[100,100,1], strideIn=nullptr or [1,1,1].
 *   
 * To retrieve the first band, but only every other elements in X direction:
 * startIn=[0,0,0], countIn=[50,100,1], strideIn=[2,1,1]. */
//TODO: check what happen if startIns is set but no countIn - countis defaults to full which should be
//larger than wha'ts avail given startIn

template<typename T>
void isce::io::IDataSet::read(T * buffer, const int * startIn, 
                                const int * countIn, 
                                const int * strideIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(startIn, countIn, strideIn);	 

    // Read dataset subset to memory
    read(buffer, dspace);

    dspace.close();
}


/** @param[in] sliceIn Vector containing an std::slice for each dimension of the dataset
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce::io::IDataSet::read(T * buffer, 
                              const std::vector<std::slice> * slicesIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(slicesIn);	 

    // Read dataset subset to memory
    read(buffer, dspace);

    dspace.close();
}

/** @param[in] gsliceIn std::gslice for subsetting
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce::io::IDataSet::read(T * buffer, const std::gslice * gsliceIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(gsliceIn);	 

    // Read dataset subset to memory
    read(buffer, dspace);

    dspace.close();
}



/** @param[in] dspace DataSpace of the subset to read
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce::io::IDataSet::read(T * buffer, const H5::DataSpace& dspace) { 
 
    // Check that the selection is valid (no out of bound)
    // TODO - to be adjusted with preferred error/message handling
    if (!dspace.selectValid()){
       std::cout << "Sub-selection of dataset is invalid" << std::endl;
       return;
    }

    // Get total number of elements to read
    hssize_t nbElements = dspace.getSelectNpoints();
    
    // Format the dataspace of the memory to receive the data read from file
    H5::DataSpace memspace = getReadMemorySpace((hsize_t)nbElements);

    // Read the dataset to memory
    H5::DataSet::read(buffer, getH5Type<T>() , memspace, dspace);
    
    // Close memory dataspaces
    memspace.close();

}







/** @param[out] buffer std::vector that will receive the full dataset.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::vector<T> &buffer) {

   read(buffer, nullptr, nullptr, nullptr);
} 

/** @param[in] startIn std::vector containing the read start location in each dimension.
 *  @param[in] countIn std::vector containing the number of elements to read in each dimension.
 *  @param[in] strideIn std::vector containing the reading stride in each dimension.
 *  @param[out] buffer std::vector that will received the read data.
 *
 *  If the output container is undersized compared to the data to read the 
*  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. 
 *
 *  startIn, countIn, strideIn must have a number of elements equals to the 
 *  rank of the dataset. 
 *  If startIn is nullptr, reading start location in each dimension is 0.
 *  If countIn is nullptr, full number of element in each dimension is read.
 *  If strideIn is nullptr, stride defaults to 1 in each dimension. */ 
template<typename T>
void isce::io::IDataSet::read(std::vector<T> &buffer, const std::vector<int> * startIn, 
                                            const std::vector<int> * countIn, 
                                            const std::vector<int> * strideIn) { 
 

    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace((startIn)  ? startIn->data() : nullptr,
                                            (countIn)  ? countIn->data() : nullptr,
                                            (strideIn) ? strideIn->data() : nullptr);

    // Check that vector is sized correctly. Adjust size if necessary
    if (buffer.size() < dspace.getSelectNpoints())
        buffer.resize(dspace.getSelectNpoints());

    // Read the data to memory
    read(buffer.data(), dspace);

    // Close dataset dataspace
    dspace.close();

}

/** @param[in] sliceIn Vector containing an std::slice for each dimension of the dataset
 *  @param[out] buffer std::vector that will receive the read data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::vector<T> &buffer, 
                              const std::vector<std::slice> * slicesIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(slicesIn);

    // Check that vector is sized correctly. Adjust size if necessary
    if (buffer.size() < dspace.getSelectNpoints())
        buffer.resize(dspace.getSelectNpoints());

    // Read the dataset to memory
    read(buffer.data(), dspace);
    
    // Close dataset dataspace
    dspace.close();

}

/** @param[in] gsliceIn std::gslice for subsetting
 *  @param[out] buffer std::vector that will receive the read data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::vector<T> &buffer, 
                              const std::gslice * gsliceIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(gsliceIn);

    // Check that vector is sized correctly. Adjust size if necessary
    if (buffer.size() < dspace.getSelectNpoints())
        buffer.resize(dspace.getSelectNpoints());

    // Read the dataset to memory
    read(buffer.data(), dspace);
    
    // Close dataset dataspace
    dspace.close();

}

/** @param[out] buffer std::valarray that will receive the full dataset.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::valarray<T> &buffer) {
   read(buffer, nullptr, nullptr, nullptr);
} 


/** @param[in] startIn std::valarray containing the read start location in each dimension.
 *  @param[in] countIn std::valarray containing the number of elements to read in each dimension.
 *  @param[in] strideIn std::valarray containing the reading stride in each dimension.
 *  @param[out] buffer std::valarray that will received the read data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. 
 *
 *  startIn, countIn, strideIn must have a number of elements equals to the 
 *  rank of the dataset. 
 *  If startIn is nullptr, reading start location in each dimension is 0.
 *  If countIn is nullptr, full number of element in each dimension is read.
 *  If strideIn is nullptr, stride defaults to 1 in each dimension. */ 
template<typename T>
void isce::io::IDataSet::read(std::valarray<T> &buffer, const std::valarray<int> *startIn, 
                                              const std::valarray<int> *countIn, 
                                              const std::valarray<int> *strideIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace((startIn)  ? &(*startIn)[0] : nullptr,
                                            (countIn)  ? &(*countIn)[0] : nullptr,
                                            (strideIn) ? &(*strideIn)[0] : nullptr);

    // Check that vector is sized correctly. Adjust size if necessary
    if (buffer.size() < dspace.getSelectNpoints())
        buffer.resize(dspace.getSelectNpoints());

    // Read the dataset to memory
    read(&buffer[0], dspace);
    
    // Close dataset dataspace
    dspace.close();

}

/** @param[in] sliceIn sts::valarray containing an std::slice for each dimension of the dataset
 *  @param[out] buffer std::valarray that will receive the read data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::valarray<T> &buffer, 
                              const std::vector<std::slice> *slicesIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(slicesIn);

    // Check that vector is sized correctly. Adjust size if necessary
    if (buffer.size() < dspace.getSelectNpoints())
        buffer.resize(dspace.getSelectNpoints());

    // Read the dataset to memory
    read(&buffer[0], dspace);
    
    // Close dataset dataspace
    dspace.close();

}

/** @param[in] gsliceIn std::gslice for subsetting
 *  @param[out] buffer std::valarray that will receive the read data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::valarray<T> &buffer, 
                              const std::gslice *gsliceIn) { 
 
    // Format a dataspace according to the input parameters       
    H5::DataSpace dspace = getReadDataSpace(gsliceIn);

    // Check that vector is sized correctly. Adjust size if necessary
    if (buffer.size() < dspace.getSelectNpoints())
        buffer.resize(dspace.getSelectNpoints());

    // Read the dataset to memory
    read(&buffer[0], dspace);
    
    // Close dataset dataspace
    dspace.close();

}




/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce::io::IDataSet::read(T *buffer, const std::string &att) { 

    // Check that attribute name is not null or empty
    if (!attrExists(att)) {
        std::cout << "Warning: Attribute: " << att << " does not exist!" << std::endl;
        return;
    }

    //read(buffer, getH5Type<T>(), att);
    //read(buffer, att);

    // Open the attribute
    H5::Attribute a = openAttribute(att);

    // Read the dataset to memory
    a.read(getH5Type<T>(), buffer);

    // Close the attribute
    a.close();
}



/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer std::vector will received the attribute data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::vector<T> &buffer, const std::string &att) { 

    if (!attrExists(att)) {
        std::cout << "Warning: Attribute: " << att << " does not exist!" << std::endl;
        return;
    }

    if (buffer.size() < getNumElements(att))
       buffer.resize(getNumElements(att));

    //read((T*)buffer.data(), getH5Type<T>(), att);
    read((T*)buffer.data(), att);
}



/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer std::valarray will received the attribute data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IDataSet::read(std::valarray<T> &buffer, const std::string &att) { 

    if (!attrExists(att)) {
        std::cout << "Warning: Attribute: " << att << " does not exist!" << std::endl;
        return;
    }

    if (buffer.size() < getNumElements(att))
       buffer.resize(getNumElements(att));

    //read((T*)&buffer[0], getH5Type<T>(), att);
    read((T*)&buffer[0], att);

}








/** @param[in] pointer to buffer to write to dataset.
 *  @param[in] DataSpace object for locating where to write the data in the dataset.
 *  */
template<typename T>
void isce::io::IDataSet::write(const T* buf, const H5::DataSpace& dspace) {


   // Check that the selection is valid (no out of bound)
   // TODO - to be adjusted with preferred error/message handling
   if (!dspace.selectValid()){
      std::cout << "Sub-selection of dataset is invalid" << std::endl;
      return;
   }

   // Construct the memory dataspace (i.e., dataspace of buf). For now, and that
   // may change in a the future, there is no possibility to subset buf. The 
   // full content of buf is to be selected. Buf dataspace is set to a 1D array 
   // of size equals to the number of elements in the vector.
   H5::DataSpace mspace = getReadMemorySpace(dspace.getSelectNpoints()); 


   // Get the datatype of the memory buffer
   //H5::DataType dtype =  memType2(typeid(T));
   H5::DataType dtype =  getH5Type<T>();

   // write the data to dataset
   H5::DataSet::write(buf, dtype, mspace, dspace);

   dtype.close();
   mspace.close();
}






/** @param[in] buf std::vector of data to write to dataset.
 *  It is mandatory that the size of the dataset and the number of elements in the 
 *  vector matches.
 */
template<typename T>
void isce::io::IDataSet::write(const std::vector<T> &buf) {
   
   // Construct the dataSpace of the file dataset. It's the full size dataset
   H5::DataSpace dspace = getSpace();

   if (buf.size() != dspace.getSelectNpoints()) {
      std::cout << "Vector container must have the same number of elements as the dataset!" << std::endl;
      // THROW ?
   }
 
   write(buf.data(), dspace);

   dspace.close();
}

 
/** @param[in] buf std::vector of data to write to dataset.
 *  @param[in] startIn std::array containing the write start location in each dimension.
 *  @param[in] countIn std::array containing the number of elements to write in each dimension.
 *  @param[in] strideIn std::array containing the writing stride in each dimension.
 */
template<typename T, size_t S>
void isce::io::IDataSet::write(const std::vector<T> &buf,
            const std::array<int,S>& startIn,
            const std::array<int,S>& countIn,
            const std::array<int,S>& strideIn) {
   
   // Construct the dataSpace of the file dataset, based on input parameters. Contrary to
   // the memory dataspace, specific parts of the file dataset can be selected for writing
   // into.
   H5::DataSpace dspace = getReadDataSpace(startIn.data(), countIn.data(), strideIn.data());

   write(buf.data(), dspace);

   dspace.close();
}


/** @param[in] buf std::vector of data to write to dataset.
 *  @param[in] sliceIn std::vector containing an std::slice for each dimension of the dataset
 */
template<typename T>
void isce::io::IDataSet::write(const std::vector<T> &buf, const std::vector<std::slice> * slicesIn) {

   // Construct the dataSpace of the file dataset, based on input parameters. Contrary to
   // the memory dataspace, specific parts of the file dataset can be selected for writing
   // into.
   H5::DataSpace dspace = getReadDataSpace(slicesIn);

   write(buf.data(), dspace);

   dspace.close();
}


/** @param[in] buf std::vector of data to write to dataset.
 *  @param[in] gsliceIn std::gslice for subsetting the dataset writing location
 */
template<typename T>
void isce::io::IDataSet::write(const std::vector<T> &buf, const std::gslice * gsliceIn) {

   // Construct the dataSpace of the file dataset, based on input parameters. Contrary to
   // the memory dataspace, specific parts of the file dataset can be selected for writing
   // into.
   H5::DataSpace dspace = getReadDataSpace(gsliceIn);

   write(buf.data(), dspace);

   dspace.close();
}




/** @param[in] buf std::valarray of data to write to dataset.
 *  It is mandatory that the size of the dataset and the number of elements in the 
 *  valarray matches.
 */
template<typename T>
void isce::io::IDataSet::write(const std::valarray<T> &buf) {
   
   // Construct the dataSpace of the file dataset. It's the full size dataset
   H5::DataSpace dspace = getSpace();

   if (buf.size() != dspace.getSelectNpoints()) {
      std::cout << "Valarray container must have the same number of elements as the dataset!" << std::endl;
      // TRHOW ?
   }

   write(&buf[0], dspace);

   dspace.close();
}


/** @param[in] buf std::valarray of data to write to dataset.
 *  @param[in] startIn std::array containing the write start location in each dimension.
 *  @param[in] countIn std::array containing the number of elements to write in each dimension.
 *  @param[in] strideIn std::array containing the writing stride in each dimension.
 */
template<typename T, size_t S>
void isce::io::IDataSet::write(const std::valarray<T> &buf,
            const std::array<int,S>& startIn,
            const std::array<int,S>& countIn,
            const std::array<int,S>& strideIn) {
   
   // Construct the dataSpace of the file dataset, based on input parameters. Contrary to
   // the memory dataspace, specific parts of the file dataset can be selected for writing
   // into.
   H5::DataSpace dspace = getReadDataSpace(startIn.data(), countIn.data(), strideIn.data());

   write(&buf[0], dspace);

   dspace.close();
}


/** @param[in] buf std::valarray of data to write to dataset.
 *  @param[in] sliceIn std::vector containing an std::slice for each dimension of the dataset
 */
template<typename T>
void isce::io::IDataSet::write(const std::valarray<T> &buf, const std::vector<std::slice> * slicesIn) {

   // Construct the dataSpace of the file dataset, based on input parameters. Contrary to
   // the memory dataspace, specific parts of the file dataset can be selected for writing
   // into.
   H5::DataSpace dspace = getReadDataSpace(slicesIn);

   write(&buf[0], dspace);

   dspace.close();
}


/** @param[in] buf std::valarray of data to write to dataset.
 *  @param[in] gsliceIn std::gslice for subsetting the dataset writing location
 */
template<typename T>
void isce::io::IDataSet::write(const std::valarray<T> &buf, const std::gslice * gsliceIn) {

   // Construct the dataSpace of the file dataset, based on input parameters. Contrary to
   // the memory dataspace, specific parts of the file dataset can be selected for writing
   // into.
   H5::DataSpace dspace = getReadDataSpace(gsliceIn);

   write(&buf[0], dspace);

   dspace.close();
}





/** @param[in] buf Raw pointer to buffer of data to write to dataset.
 *  The size of the dataset and the number of elements in the buffer must match.
 */
template<typename T>
void isce::io::IDataSet::write(const T* buf, const size_t sz) {
   
   // Construct the dataSpace of the file dataset. It's the full size dataset
   H5::DataSpace dspace = getSpace();

   if (sz != dspace.getSelectNpoints()) {
      std::cout << "Buffer must have the same number of elements as the dataset!" << std::endl;
      //THROW ?
   }
 
   write(buf, dspace);

   dspace.close();
}

/** @param[in] buf raw pointer to a buffer of data to write to dataset.
 *  @param[in] startIn std::array containing the write start location in each dimension.
 *  @param[in] countIn std::array containing the number of elements to write in each dimension.
 *  @param[in] strideIn std::array containing the writing stride in each dimension.
 *
 * It the responsability of the caller to make sure that the size of the buffer inferred from
 * the startIn/countIn/strideIn matches the actual size of the buffer.
 */
template<typename T, size_t S>
void isce::io::IDataSet::write(const T* buf,
            const std::array<int,S>& startIn,
            const std::array<int,S>& countIn,
            const std::array<int,S>& strideIn) {
   
   // Construct the dataSpace of the file dataset, based on input parameters. Contrary to
   // the memory dataspace, specific parts of the file dataset can be selected for writing
   // into.
   H5::DataSpace dspace = getReadDataSpace(startIn.data(), countIn.data(), strideIn.data());

   write(buf, dspace);

   dspace.close();
}


/** @param[in] buf raw pointer to a buffer of data to write to dataset.
 *  @param[in] sliceIn std::vector containing an std::slice for each dimension of the dataset
 *
 * It the responsability of the caller to make sure that the size of the buffer inferred from
 * the startIn/countIn/strideIn matches the actual size of the buffer.
 */
template<typename T>
void isce::io::IDataSet::write(const T* buf, const std::vector<std::slice> * slicesIn) {

   // Construct the dataSpace of the file dataset, based on input parameters. Contrary to
   // the memory dataspace, specific parts of the file dataset can be selected for writing
   // into.
   H5::DataSpace dspace = getReadDataSpace(slicesIn);

   write(buf, dspace);

   dspace.close();
}


/** @param[in] buf raw pointer to a buffer of data to write to dataset.
 *  @param[in] gsliceIn std::gslice for subsetting the dataset writing location
 *
 * It the responsability of the caller to make sure that the size of the buffer inferred from
 * the startIn/countIn/strideIn matches the actual size of the buffer.
 */
template<typename T>
void isce::io::IDataSet::write(const T* buf, const std::gslice * gsliceIn) {

   // Construct the dataSpace of the file dataset, based on input parameters. Contrary to
   // the memory dataspace, specific parts of the file dataset can be selected for writing
   // into.
   H5::DataSpace dspace = getReadDataSpace(gsliceIn);

   write(buf, dspace);

   dspace.close();
}








/** 
 * @param[in] name Name of the dataset attribute to create
 * @param[in] datatype H5 data type of the attribute
 * @param[in] dataspace H5 data space of the attribute
 * @param[in] buffer Raw pointer to attribute data to write
 *
 * This is for any non-string type. String type is handled with a specialized function
 */
template<typename T>
void isce::io::IDataSet::createAttribute(
        const std::string& name, 
        const H5::DataType& datatype,
        const H5::DataSpace& dataspace,
        const T* buffer) {

   if (name.empty()) {
       std::cout << "Can't have an empty name for Attribute creation!" << std::endl;
       //THROW ERROR
   }

   if (attrExists(name.c_str())) {
       std::cout << "Attribute already exists!" << std::endl;
       //THROW ERROR
   }

   // Create the attribute
   H5::Attribute attribute =  H5::H5Object::createAttribute(name, datatype, dataspace);

   // Write the attribute data. 
   attribute.write(datatype, buffer);

   attribute.close();

}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] dims Array containing the size of each dimension of the attribute
 * @param[in] buffer std::vector of attribute data to write
 */
template<typename T, typename T2, size_t S>
inline void isce::io::IDataSet::createAttribute(
        const std::string& name, 
        const std::array<T2, S>& dims,
        const std::vector<T>& buffer) {
   
   createAttribute(name, getH5Type<T>(), getReadMemorySpace(dims), buffer.data());
}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] dims Array containing the size of each dimension of the attribute
 * @param[in] buffer std::valarray of attribute data to write
 */
template<typename T, typename T2, size_t S>
inline void isce::io::IDataSet::createAttribute(
        const std::string& name, 
        const std::array<T2, S>& dims,
        const std::valarray<T>& buffer) {

   createAttribute(name, getH5Type<T>(), getReadMemorySpace(dims), &buffer[0]);
}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] dims Array containing the size of each dimension of the attribute
 * @param[in] buffer Raw pointer buffer to attribute data to write
 */
template<typename T, typename T2, size_t S>
inline void isce::io::IDataSet::createAttribute(
        const std::string& name, 
        const std::array<T2, S>& dims,
        const T* buffer) {

   createAttribute(name, getH5Type<T>(), getReadMemorySpace(dims), buffer);
}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] buffer std::vector of attribute data to write
 *
 * The shape of the attribute is 1D.
 */
template<typename T>
inline void isce::io::IDataSet::createAttribute(
        const std::string& name, 
        const std::vector<T>& data) {

   std::array<hsize_t,1> dims = {static_cast<hsize_t>(data.size())};
   createAttribute(name, dims, data);

}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] buffer std::valarray of attribute data to write
 *
 * The shape of the attribute is 1D.
 */
template<typename T>
inline void isce::io::IDataSet::createAttribute(
        const std::string& name, 
        const std::valarray<T>& data) {

   std::array<hsize_t,1> dims = {static_cast<hsize_t>(data.size())};
   createAttribute(name, dims, data);
}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] data Reference to scalar attribute value
 */
template<typename T>
inline void isce::io::IDataSet::createAttribute(
        const std::string& name, 
        const T& data) {

   createAttribute(name, getH5Type<T>(), H5::DataSpace(), &data);
}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] data String scalar attribute
 */
inline void isce::io::IDataSet::createAttribute(
        const std::string& name, 
        const std::string& data) {


   createAttribute(name, getH5Type<std::string>(), H5::DataSpace(), data.c_str());
}

















/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 *                                          IGROUP CLASS
 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
*/





/** @param[in] att  Name of the attribute 
 *  @param[out] v   Attribute scalar value (numeric type).
 *
 *  Reads the value of the numeral attribute contained in the current group.
 *  For attribute containing more than one element, see other functions 
 *  signature. For attribute of string type, see other signature.*/
template<typename T>
void isce::io::IGroup::read(T &v, const std::string &att) {
         
    // Check that the parameter that will receive the data read from the file 
    // is a numeric variable
    //static_assert(std::is_arithmetic<T>::value, "Expected a numeric scalar");
    if (attrExists(att)) {
       // Open the attribute
       H5::Attribute a = openAttribute(att);

       // Get the dataSpace of the attribute
       H5::DataSpace dspace = a.getSpace();

       // If attribute contains a scalar or a 1-element array, read the attribute's 
       // value
       if (dspace.getSimpleExtentNdims() == 0)
          a.read(getH5Type<T>(), &v);
       
       else {} // TODO warning/trow? 
                                   
                                            
       // Close the attribute and dataspace
       a.close();
       dspace.close();
    }
    else {}   // TODO Should warn or throw here

    return;
}





/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce::io::IGroup::read(T *buffer, const std::string &att) { 

    // Check that attribute name is not null or empty
    if (!attrExists(att)) {
        std::cout << "Warning: Attribute: " << att << " does not exist!" << std::endl;
        return;
    }

    // Open the attribute
    H5::Attribute a = openAttribute(att);

    // Read the dataset to memory
    a.read(getH5Type<T>(), buffer);

    // Close the attribute
    a.close();
}



/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer std::vector will received the attribute data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IGroup::read(std::vector<T> &buffer, const std::string &att) { 

    if (!attrExists(att)) {
        std::cout << "Warning: Attribute: " << att << " does not exist!" << std::endl;
        return;
    }

    if (buffer.size() < getNumElements(att))
       buffer.resize(getNumElements(att));

    read(buffer.data(), att);
}



/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer std::valarray will received the attribute data.
 *
 *  If the output container is undersized compared to the data to read the 
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce::io::IGroup::read(std::valarray<T> &buffer, const std::string &att) { 

    if (!attrExists(att)) {
        std::cout << "Warning: Attribute: " << att << " does not exist!" << std::endl;
        return;
    }

    if (buffer.size() < getNumElements(att))
       buffer.resize(getNumElements(att));

    read(&buffer[0], att);

}





/** 
 * @param[in] name Name of the dataset to create
 * @param[in] data Scalar (non std::string) data to write to the dataset
 *
 * The dataset is a 1-element dataset
 */
template<typename T>
inline isce::io::IDataSet isce::io::IGroup::createDataSet(
                const std::string &name,
                const T& data) {

   H5::DataType dtype = getH5Type<T>();
   H5::DataSet dset =  H5::Group::createDataSet(name, dtype, H5::DataSpace());
   dset.write(&data, dtype);

   dtype.close();

   return IDataSet(dset);

}



/** 
 * @param[in] name Name of the dataset to create
 * @param[in] data std::vector of data to write to the dataset
 *
 * The shape of the dataset is 1D. The number of dataset points is
 * inferred from the size of the input data vector. The dataset type
 * is same as data type.
 */
template<typename T>
inline isce::io::IDataSet isce::io::IGroup::createDataSet(
                const std::string &name,
                const std::vector<T> &data) {

   // Default to 1D array dataset with this interface 
   std::array<hsize_t, 1> dims{{data.size()}};

   return createDataSet(name, data, dims);

}


/** 
 * @param[in] name Name of the dataset to create
 * @param[in] data std::valarray of data to write to the dataset
 *
 * The shape of the dataset is 1D. The number of dataset points is
 * inferred from the size of the input data valarray. The dataset
 * type is same as data type.
 */
template<typename T>
inline isce::io::IDataSet isce::io::IGroup::createDataSet(
               const std::string &name,
               const std::valarray<T> &data) {

   // Default to 1D array dataset with this interface 
   std::array<hsize_t, 1> dims{{data.size()}};

   return createDataSet(name, data, dims);

}


/** 
 * @param[in] name Name of the dataset to create
 * @param[in] data Raw pointer to data to write to the dataset
 * @param[in] sz   Number of points in the raw pointer buffer
 *
 * The shape of the dataset is 1D. The dataset type is same as
 * data type.
 */
template<typename T>
inline isce::io::IDataSet isce::io::IGroup::createDataSet(
               const std::string &name,
               const T* data,
               const size_t sz) {

   // Default to 1D array dataset with this interface 
   std::array<hsize_t, 1> dims{{sz}};

   return createDataSet(name, data, dims);

}




/** 
 * @param[in] name Name of the dataset to create
 * @param[in] data std::vector of data to write to the dataset
 * @param[in] dims Array containing the size of each dimension of the dataset
 *
 * The dataset type is same as data type.
 */
template<typename T, typename T2, size_t S>
inline isce::io::IDataSet isce::io::IGroup::createDataSet(
               const std::string &name,
               const std::vector<T> &data,
               const std::array<T2, S> &dims) {

   IDataSet dset = createDataSet<T>(name, dims);
   dset.write(data);
   return dset;

}


/** 
 * @param[in] name Name of the dataset to create
 * @param[in] data std::valarray of data to write to the dataset
 * @param[in] dims Array containing the size of each dimension of the dataset
 *
 * The dataset type is same as data type.
 */
template<typename T, typename T2, size_t S>
inline isce::io::IDataSet isce::io::IGroup::createDataSet(
               const std::string &name,
               const std::valarray<T> &data,
               const std::array<T2, S> &dims) {

   IDataSet dset = createDataSet<T>(name, dims);
   dset.write(data);
   return dset;

}


/** 
 * @param[in] name Name of the dataset to create
 * @param[in] data Raw pointer to buffer towrite to the dataset
 * @param[in] dims Array containing the size of each dimension of the dataset
 *
 * The dataset type is same as data type.
 */
template<typename T, typename T2, size_t S>
inline isce::io::IDataSet isce::io::IGroup::createDataSet(
               const std::string &name,
               const T* data,
               const std::array<T2, S> &dims) {

   IDataSet dset = createDataSet<T>(name, dims);
   dset.write(data, dset.getSpace().getSimpleExtentNpoints());
   return dset;

}





/** 
 * @param[in] name Name of the dataset to create
 * @param[in] dims Array containing the size of each dimension of the dataset
 * @param[in] chunk 1/0 flag to set dataset chunking
 * @param[in] shuffle 1/0 flag to set byte shuffling
 * @param[in] deflate [0..9] level of dataset compression
 *
 * This interface just create the dataset and does not write any data. Writing is done
 * with the IDataSet write function. To use API specific format (float16, complex,..), 
 * this function to create dataset has to be used. Chunking is set to 128x128 chunk on the
 * fastest 2 dimensions only. It is automatically activated if shuffle, deflate or a specfic
 * API format is used. If datatype is of NBIT type (i.e., float16, complex16, n1Bit, n2Bit, 
 * the NBIT filter is automatically activated if the chunking is activated.
 */
template<typename T, typename T2, size_t S>
isce::io::IDataSet isce::io::IGroup::createDataSet(
        const std::string &name,
        const std::array<T2, S> &dims,
        const int chunk,
        const int shuffle,
        const int deflate) {


   if (name.empty()) {
       std::cout << "Can't have an empty name for DataSet creation!" << std::endl;
       //THROW ERROR
   }

   // Create the dataspace
   hsize_t dims2[dims.size()];
   for(int i=0; i<dims.size(); i++)
      dims2[i] = (hsize_t)dims[i];
   H5::DataSpace dataSpace((int)dims.size(), dims2);

   // Create the dataset creation properties. 
   H5::DSetCreatPropList cparms;

   // Adjust dataset creation properties if necessary. This is only the case if
   // one of the three last parameters is activated (!=0).
   if (chunk!=0 || shuffle!=0 || deflate!=0) {

      // No matter which option was used, chunking is mandatory. Only chunk the
      // first 2 dimensions, which corresponds to X, Y. The third dimension (the "band" one) 
      // and others doe not get chunked
      hsize_t chunks[dims.size()];
      std::fill_n(chunks, dims.size(), 1);
      chunks[0] = chunkSizeX;
      if (dims.size() > 1) chunks[1] = chunkSizeY;
      cparms.setChunk(dims.size(), chunks);


      // Set the NBIT compression. 
      // Only if the datatype is of nbit precision (float16, complex float16,..). Otherwise tests show
      // degraded compression performance
      if ((typeid(T)==typeid(isce::io::float16)) || (typeid(T)==typeid(std::complex<isce::io::float16>)) ||
          (typeid(T)==typeid(isce::io::n1bit)) || (typeid(T)==typeid(isce::io::n2bit))) 
         cparms.setNbit();


      // Set the byte shuffling if asked for
      if (shuffle != 0)
         cparms.setShuffle();

      // Set the compression level if asked for
      if (deflate != 0) {
         if (deflate < 0) {
            std::cout << "Dataset Deflate compression factor should be [0..9] - defaulting to 0" << std::endl;
            cparms.setDeflate(0);
         }
         else if (deflate > 9) {
            std::cout << "Dataset Deflate compression factor should be [0..9] - defaulting to 9" << std::endl;
            cparms.setDeflate(9);
         }
         else cparms.setDeflate(deflate);
      }

    }

    // Create the dataset
    H5::DataSet dataset =  H5::Group::createDataSet(name, getH5Type<T>(), dataSpace, cparms);
   
    dataSpace.close();
    cparms.close();

    return IDataSet(dataset);
}








/** 
 * @param[in] name Name of the group attribute to create
 * @param[in] datatype H5 data type of the attribute
 * @param[in] dataspace H5 data space of the attribute
 * @param[in] buffer Raw pointer to attribute data to write
 *
 * This is for any non-string type. String type is handled with a specialized function
 */
template<typename T>
void isce::io::IGroup::createAttribute(
        const std::string& name, 
        const H5::DataType& datatype,
        const H5::DataSpace& dataspace,
        const T* buffer) {

   if (name.empty()) {
       std::cout << "Can't have an empty name for Attribute creation!" << std::endl;
       //THROW ERROR
   }

   if (attrExists(name.c_str())) {
       std::cout << "Attribute already exists!" << std::endl;
       //THROW ERROR
   }

   // Create the attribute
   H5::Attribute attribute =  H5::H5Object::createAttribute(name, datatype, dataspace);

   // Write the attribute data. 
   attribute.write(datatype, buffer);

   attribute.close();

}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] dims Array containing the size of each dimension of the attribute
 * @param[in] buffer std::vector of attribute data to write
 */
template<typename T, typename T2, size_t S>
inline void isce::io::IGroup::createAttribute(
        const std::string& name, 
        const std::array<T2, S>& dims,
        const std::vector<T>& buffer) {

   createAttribute(name, getH5Type<T>(), getReadMemorySpace(dims), buffer.data());
}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] dims Array containing the size of each dimension of the attribute
 * @param[in] buffer std::valarray of attribute data to write
 */
template<typename T, typename T2, size_t S>
inline void isce::io::IGroup::createAttribute(
        const std::string& name, 
        const std::array<T2, S>& dims,
        const std::valarray<T>& buffer) {

   createAttribute(name, getH5Type<T>(), getReadMemorySpace(dims), &buffer[0]);
}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] dims Array containing the size of each dimension of the attribute
 * @param[in] buffer Raw pointer buffer to attribute data to write
 */
template<typename T, typename T2, size_t S>
inline void isce::io::IGroup::createAttribute(
        const std::string& name, 
        const std::array<T2, S>& dims,
        const T* buffer) {

   createAttribute(name, getH5Type<T>(), getReadMemorySpace(dims), buffer);
}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] buffer std::vector of attribute data to write
 *
 * The shape of the attribute is 1D.
 */
template<typename T>
inline void isce::io::IGroup::createAttribute(
        const std::string& name, 
        const std::vector<T>& data) {

   std::array<hsize_t,1> dims = {static_cast<hsize_t>(data.size())};
   createAttribute(name, dims, data);

}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] buffer std::valarray of attribute data to write
 *
 * The shape of the attribute is 1D.
 */
template<typename T>
inline void isce::io::IGroup::createAttribute(
        const std::string& name, 
        const std::valarray<T>& data) {

   std::array<hsize_t,1> dims = {static_cast<hsize_t>(data.size())};
   createAttribute(name, dims, data);
}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] data Reference to scalar attribute value
 */
template<typename T>
inline void isce::io::IGroup::createAttribute(
        const std::string& name, 
        const T& data) {

   createAttribute(name, getH5Type<T>(), H5::DataSpace(), &data);
}


/** 
 * @param[in] name Name of the attribute to create
 * @param[in] data String scalar attribute
 */
inline void isce::io::IGroup::createAttribute(
        const std::string& name, 
        const std::string& data) {


   createAttribute(name, getH5Type<std::string>(), H5::DataSpace(), data.c_str());
}











// end of file
