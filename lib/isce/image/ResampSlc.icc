//-*- C++ -*-
//-*- coding: utf-8 -*-

#if !defined(ISCE_IMAGE_RESAMPSLC_ICC)
#error "ResampSlc.icc is an implementation detail of class ResampSlc"
#endif

// Since fmod(a,b) in C++ != MODULO(a,b) in Fortran for all a,b, define a C++ equivalent
#define modulo_f(a,b) fmod(fmod(a,b)+(b),(b))

// Default constructor (assumes zero-Doppler imaging and no flattening)
isce::image::ResampSlc::
ResampSlc() : _haveRefMode(false) {
    // Make a zero-doppler Polynomial
    isce::core::Poly2d zerodop(0, 0, 0.0, 0.0, 1.0, 1.0);
    _dopplerPoly = zerodop;
    // Create an empty ImageMode
    isce::product::ImageMode mode;
    _mode = mode;
}

// Constructor from an isce::product::Product
isce::image::ResampSlc::
ResampSlc(const isce::product::Product & product) : _haveRefMode(false) {
    // Cache the instrument
    isce::radar::Radar instrument = product.metadata().instrument();
    // Set the doppler
    _dopplerPoly = instrument.contentDoppler();
    // Set the image mode
    _mode = product.complexImagery().primaryMode();
    // Save the filename
    _filename = product.filename();
}

// Constructor from isce::core::Poly2d and isce::product::ImageMode
isce::image::ResampSlc::
ResampSlc(const isce::core::Poly2d & doppler, const isce::product::ImageMode & mode) :
    _dopplerPoly(doppler), _mode(mode), _haveRefMode(false) {
    // _filename variable set to empty string since it shouldn't be used with
    // a non-HDF5 constructor
    _filename = " ";
}

// Constructor from isce::core objects
isce::image::ResampSlc::
ResampSlc(const isce::core::Poly2d & doppler, const isce::core::Metadata & meta) :
    _dopplerPoly(doppler), _mode(meta) {
    // _filename variable set to empty string since it shouldn't be used with
    // a non-HDF5 constructor
    _filename = " ";
}

// Destructor
isce::image::ResampSlc::
~ResampSlc() {}

// Get range carrier polynomial
isce::core::Poly2d
isce::image::ResampSlc::
rgCarrier() const {
    return _rgCarrier;
}

// Set range carrier polynomial
void isce::image::ResampSlc::
rgCarrier(isce::core::Poly2d & poly) {
    _rgCarrier = poly;
}

// Get azimuth carrier polynomial
isce::core::Poly2d
isce::image::ResampSlc::
azCarrier() const {
    return _azCarrier;
}

// Set azimuth carrier polynomial
void isce::image::ResampSlc::
azCarrier(isce::core::Poly2d & poly) {
    _azCarrier = poly;
}

// Get Doppler polynomial
isce::core::Poly2d
isce::image::ResampSlc::
doppler() const {
    return _dopplerPoly;
}

// Set Doppler polynomial
void isce::image::ResampSlc::
doppler(isce::core::Poly2d & poly) {
    _dopplerPoly = poly;
}

// Set reference product
void isce::image::ResampSlc::
referenceProduct(const isce::product::Product & refProduct) {
    // Extract the reference image mode
    _refMode = refProduct.complexImagery().primaryMode();
    // Indicate we have a reference mode
    _haveRefMode = true;
}

// Get image mode
isce::product::ImageMode
isce::image::ResampSlc::
imageMode() const {
    return _mode;
}

// Set imageMode from copy
void isce::image::ResampSlc::
imageMode(const isce::product::ImageMode & mode) {
    _mode = mode;
}

// Get reference imageMode
isce::product::ImageMode
isce::image::ResampSlc::
refImageMode() const {
    return _refMode;
}

// Set reference imageMode from copy
void isce::image::ResampSlc::
refImageMode(const isce::product::ImageMode & mode) {
    _refMode = mode;
}

// Announce my properties to the world
void isce::image::ResampSlc::
declare(int inLength, int inWidth,
    int outLength, int outWidth) const {
    // Make info channel
    pyre::journal::info_t channel("isce.core.ResampSlc");
    // Basic info
    channel << pyre::journal::newline
            << "Resample one image to another image coordinates >>"
            << pyre::journal::newline << pyre::journal::newline;
    channel << "Input Image Dimensions:  " << inLength << " lines, "
            << inWidth << " pixels" 
            << pyre::journal::newline;
    channel << "Output Image Dimensions: " << outLength << " lines, "
            << outWidth << " pixels"
            << pyre::journal::newline << pyre::journal::newline;
    //channel << "Number of threads: " << omp_get_max_threads() << pyre::journal::newline;
    channel << "Complex data interpolation" << pyre::journal::newline;
    // Polynomial info
    channel << "Azimuth Carrier Poly" << pyre::journal::newline;
    for (int j = 0; j <= _azCarrier.rangeOrder; ++j)
        channel << _azCarrier.getCoeff(0, j) << " ";
    channel << pyre::journal::newline;
    channel << "Range Carrier Poly" << pyre::journal::newline;
    for (int j = 0; j <= _rgCarrier.rangeOrder; ++j)
        channel << _rgCarrier.getCoeff(0, j) << " ";
    channel << pyre::journal::newline;
    channel << "Doppler Poly" << pyre::journal::newline;
    for (int j = 0; j <= _dopplerPoly.rangeOrder; ++j)
        channel << _dopplerPoly.getCoeff(0, j) << " ";
    channel << pyre::journal::endl;
}

// Get the number of lines per tile
size_t isce::image::ResampSlc::
linesPerTile() const {
    return _linesPerTile;
}

// Set the number of lines per tile
void isce::image::ResampSlc::
linesPerTile(size_t value) {
    _linesPerTile = value;
}

// Compute number of tiles given a specified nominal tile size
int isce::image::ResampSlc::
_computeNumberOfTiles(int outLength, int linesPerTile) {
    // Compute floor(nTiles)
    int nTiles = outLength / linesPerTile;
    // See if there are any leftover lines to add an extra tile
    int extraLines = outLength - nTiles * linesPerTile;
    if (extraLines > 0) {
        nTiles += 1;
    }
    return nTiles;
}

// Prepare sinc interpolation methods and internal data
void isce::image::ResampSlc::
_prepareInterpMethods(int method) {
    // Compute filter coefficients    
    if (method == isce::core::SINC_METHOD) {

        // Initialize sinc coefficients
        std::valarray<double> filter(0.0, SINC_SUB * SINC_LEN + 1);
        isce::core::Interpolator::sinc_coef(1.0, SINC_LEN, SINC_SUB, 0.0, 1, filter);

        // Normalize filter
        for (int i = 0; i < SINC_SUB; ++i) {
            // Compute filter sum
            double ssum = 0.0;
            for (int j = 0; j < SINC_LEN; ++j) {
                ssum += filter[i + SINC_SUB*j];
            }
            // Normalize the filter
            for (int j = 0; j < SINC_LEN; ++j) {
                filter[i + SINC_SUB*j] /= ssum;
            }
        }

        // Copy transpose of filter coefficients to member data
        _fintp.resize(SINC_SUB, SINC_LEN);
        for (int i = 0; i < SINC_LEN; ++i) {
            for (int j = 0; j < SINC_SUB; ++j) {
                _fintp(j,i) = filter[j + SINC_SUB*i];
            }
        }
    } else {
        std::cerr << "Error: other interpolation methods for ResampSlc not implemented yet."
                  << std::endl;
    }
    // done
}

// Complex sinc interpolation
std::complex<float> isce::image::ResampSlc::
_interpolateComplex(isce::core::Matrix<std::complex<float>> & ifg, int x, int y,
                    double fx, double fy, int nx, int ny) {

    // Check edge conditions
    if ((x < SINC_HALF) || (x > (nx - SINC_HALF)))
        return std::complex<float>(0.0, 0.0);
    if ((y < SINC_HALF) || (y > (ny - SINC_HALF)))
        return std::complex<float>(0.0, 0.0);

    // Modify interpolation coordinates
    const int xx = x + SINC_HALF - 1;
    const int yy = y + SINC_HALF - 1;

    // Call sinc interpolator
    std::complex<float> interpVal = isce::core::Interpolator::sinc_eval_2d(
        ifg, _fintp, xx, yy, fx, fy, nx, nx
    );
    return interpVal;
}

// end of file
