//-*- C++ -*-
//-*- coding: utf-8 -*-

#if !defined(ISCE_IMAGE_RESAMPSLC_ICC)
#error "ResampSlc.icc is an implementation detail of class ResampSlc"
#endif

// Since fmod(a,b) in C++ != MODULO(a,b) in Fortran for all a,b, define a C++ equivalent
#define modulo_f(a,b) fmod(fmod(a,b)+(b),(b))

/** Constructor from an isce::product::Product */
isce::image::ResampSlc::
ResampSlc(const isce::product::Product & product, char frequency) : 
          ResampSlc(product.swath(frequency)) {
    // Set the doppler
    _dopplerLUT = product.metadata().procInfo().dopplerCentroid(frequency);
    // Save the filename
    _filename = product.filename();
}

/** Constructor from an isce::product::Product and reference product (flattening) */
isce::image::ResampSlc::
ResampSlc(const isce::product::Product & product,
          const isce::product::Product & refProduct,
          char frequency) :
          ResampSlc(product.swath(frequency),
                    refProduct.swath(frequency)) {
    // Set the doppler
    _dopplerLUT = product.metadata().procInfo().dopplerCentroid(frequency);
    // Save the filename
    _filename = product.filename();
}

/** Constructor from an isce::product::Swath (no flattening) */
isce::image::ResampSlc::
ResampSlc(const isce::product::Swath & swath) : _haveRefData(false) {
    // Set radar parameters
    _setDataFromSwath(swath);
}

/** Constructor from an isce::product::Swath and reference swath (flattening) */
isce::image::ResampSlc::
ResampSlc(const isce::product::Swath & swath, const isce::product::Swath & refSwath) :
          _haveRefData(true) {
    // Set radar parameters
    _setDataFromSwath(swath);
    // Set reference radar parameters
    _setRefDataFromSwath(refSwath);
}

/** Constructor from individual components (no flattening) */
isce::image::ResampSlc::
ResampSlc(const isce::core::LUT2d<double> & doppler, double startingRange,
          double rangePixelSpacing, double sensingStart, double prf, double wvl) :
          _haveRefData(false), _dopplerLUT(doppler), _startingRange(startingRange),
          _rangePixelSpacing(rangePixelSpacing), _sensingStart(sensingStart),
          _prf(prf), _wavelength(wvl) {}

/** Constructor from individual components (flattening) */
isce::image::ResampSlc::
ResampSlc(const isce::core::LUT2d<double> & doppler, double startingRange,
          double rangePixelSpacing, double sensingStart, double prf, double wvl,
          double refStartingRange, double refRangePixelSpacing, double refWvl) :
          _haveRefData(true), _dopplerLUT(doppler), _startingRange(startingRange),
          _rangePixelSpacing(rangePixelSpacing), _sensingStart(sensingStart),
          _prf(prf), _wavelength(wvl), _refStartingRange(refStartingRange),
          _refRangePixelSpacing(refRangePixelSpacing), _refWavelength(refWvl) {}

// Set radar parameters from an isce::product::Swath
/** @param[in] swath            Input isce::product::Swath */
void
isce::image::ResampSlc::
_setDataFromSwath(const isce::product::Swath & swath) {
    _startingRange = swath.slantRange()[0];
    _rangePixelSpacing = swath.rangePixelSpacing();
    _sensingStart = swath.zeroDopplerTime()[0];
    _prf = swath.nominalAcquisitionPRF();
    _wavelength = swath.processedWavelength();
}

// Set reference radar parameters from an isce::product::Swath (for flattening)
/** @param[in] swath            Input isce::product::Swath */
void
isce::image::ResampSlc::
_setRefDataFromSwath(const isce::product::Swath & swath) {
    _refStartingRange = swath.slantRange()[0];
    _refRangePixelSpacing = swath.rangePixelSpacing();
    _refWavelength = swath.processedWavelength();
}

// Get range carrier polynomial
isce::core::Poly2d
isce::image::ResampSlc::
rgCarrier() const {
    return _rgCarrier;
}

// Set range carrier polynomial
void isce::image::ResampSlc::
rgCarrier(const isce::core::Poly2d & lut) {
    _rgCarrier = lut;
}

// Get azimuth carrier polynomial
isce::core::Poly2d
isce::image::ResampSlc::
azCarrier() const {
    return _azCarrier;
}

// Set azimuth carrier polynomial
void isce::image::ResampSlc::
azCarrier(const isce::core::Poly2d & lut) {
    _azCarrier = lut;
}

// Get read-only reference to Doppler LUT
const isce::core::LUT2d<double> &
isce::image::ResampSlc::
doppler() const {
    return _dopplerLUT;
}

// Get reference to Doppler LUT
isce::core::LUT2d<double> &
isce::image::ResampSlc::
doppler() {
    return _dopplerLUT;
}

// Set Doppler LUT
void isce::image::ResampSlc::
doppler(const isce::core::LUT2d<double> & lut) {
    _dopplerLUT = lut;
}

// Set reference product
void isce::image::ResampSlc::
referenceProduct(const isce::product::Product & refProduct, char frequency) {
    _setRefDataFromSwath(refProduct.swath(frequency));
    _haveRefData = true;
}

// Announce my properties to the world
void isce::image::ResampSlc::
declare(int inLength, int inWidth,
    int outLength, int outWidth) const {
    // Make info channel
    pyre::journal::info_t channel("isce.core.ResampSlc");
    // Basic info
    channel << pyre::journal::newline
            << "Resample one image to another image coordinates >>"
            << pyre::journal::newline << pyre::journal::newline;
    channel << "Input Image Dimensions:  " << inLength << " lines, "
            << inWidth << " pixels" 
            << pyre::journal::newline;
    channel << "Output Image Dimensions: " << outLength << " lines, "
            << outWidth << " pixels"
            << pyre::journal::newline << pyre::journal::newline;
    //channel << "Number of threads: " << omp_get_max_threads() << pyre::journal::newline;
    channel << "Complex data interpolation" << pyre::journal::newline;
}

// Get the number of lines per tile
size_t isce::image::ResampSlc::
linesPerTile() const {
    return _linesPerTile;
}

// Set the number of lines per tile
void isce::image::ResampSlc::
linesPerTile(size_t value) {
    _linesPerTile = value;
}

// Compute number of tiles given a specified nominal tile size
int isce::image::ResampSlc::
_computeNumberOfTiles(int outLength, int linesPerTile) {
    // Compute floor(nTiles)
    int nTiles = outLength / linesPerTile;
    // See if there are any leftover lines to add an extra tile
    int extraLines = outLength - nTiles * linesPerTile;
    if (extraLines > 0) {
        nTiles += 1;
    }
    return nTiles;
}

// Prepare interpolation pointer
void isce::image::ResampSlc::
_prepareInterpMethods(isce::core::dataInterpMethod, int sinc_len) {
    _interp = new isce::core::Sinc2dInterpolator<std::complex<float>>(
                  sinc_len, isce::core::SINC_SUB);
}

// end of file
